(ns audio-platform.services.media
  (:require
   ["package:file_picker/file_picker.dart" :as file-picker]
   ["package:http/http.dart" :as http]
   ["dart:io" :as io]
   ["dart:async" :as async]
   [clojure.string :as str]
   [audio-platform.services.api :as api]
   [audio-platform.state :as state]))

;; Generic file upload function with progress reporting
(defn upload-file [file-path presigned-url content-type on-progress]
  (let [file (io/File file-path)
        total-bytes (.lengthSync file)
        request (http/StreamedRequest. "PUT" (dart:core/Uri.parse presigned-url))
        client (http/Client.)]
    (set! (.-contentLength request) total-bytes)
    (.addAll (.-headers request) {"Content-Type" content-type})
    
    (let [bytes-sent (atom 0)
          stream (.openRead file)]
      (async/Future.
       (fn []
         (let [completer (async/Completer.)]
           (-> (.listen stream
                        (fn [chunk]
                          (swap! bytes-sent + (count chunk))
                          (when on-progress
                            (on-progress (/ @bytes-sent total-bytes)))
                          (.add (.-sink request) chunk))
                        .onDone (fn []
                                  (.close (.-sink request)))
                        .onError (fn [err]
                                   (.close (.-sink request))
                                   (.completeError completer err)))
               (.then (fn [_]
                        (-> (.send client request)
                            (.then (fn [streamed-response]
                                     (-> (http/Response.fromStream streamed-response)
                                         (.then (fn [response]
                                                  (.complete completer response))))))
                            (.catchError (fn [err]
                                           (.completeError completer err)))))))
           (.-future completer)))))))

(defn get-content-type [file-name]
  (let [ext (-> file-name (str/split #"\.") last str/lower-case)]
    (cond
      (or (= ext "jpg") (= ext "jpeg")) "image/jpeg"
      (= ext "png") "image/png"
      (= ext "gif") "image/gif"
      (= ext "mp3") "audio/mpeg"
      (= ext "wav") "audio/wav"
      :else "application/octet-stream")))

(defn- handle-upload-result [session-data file-path file-name file-size detected-content-type on-progress]
  (let [media-id (get session-data "media_id")
        presigned-url (get session-data "presigned_url")]
    (-> (upload-file file-path presigned-url detected-content-type on-progress)
        (.then 
         (fn [response]
           (let [status-code (.-statusCode response)]
             (if (not (and (>= status-code 200) (< status-code 300)))
               (throw (dart:core/Exception (str "Upload failed: HTTP " status-code)))
               (-> (api/mark-upload-complete (state/get-token) media-id :file-size file-size)
                   (.then (fn [_]
                            {:media-id media-id
                             :url (str api/base-url "/media/" media-id)
                             :file-info {:path file-path
                                        :name file-name
                                        :size file-size}}))))))))))

(defn- handle-picker-result [result on-progress content-type]
  (if (or (nil? result) (nil? (.-files result)) (empty? (.-files result)))
    (throw (dart:core/Exception "No file selected"))
    (let [file (first (.-files result))
          file-path (.-path file)
          file-name (.-name file)
          file-size (.-size file)
          detected-content-type (or content-type (get-content-type file-name))]
      (-> (api/create-upload-session (state/get-token) file-name :file-size file-size)
          (.then (fn [session-data]
                   (handle-upload-result session-data file-path file-name file-size detected-content-type on-progress)))))))

(defn pick-and-upload-file [& {:keys [type allowed-extensions on-progress content-type]}]
  (let [resolved-type (case type
                        :audio file-picker.FileType/audio
                        :image file-picker.FileType/image
                        :video file-picker.FileType/video
                        :media file-picker.FileType/media
                        :any file-picker.FileType/any
                        :custom file-picker.FileType/custom
                        (or type file-picker.FileType/any))]
    (-> (file-picker/FilePicker.platform.pickFiles
         .type resolved-type
         .allowedExtensions allowed-extensions
         .allowMultiple false)
        (.then (fn [result] (handle-picker-result result on-progress content-type))))))
