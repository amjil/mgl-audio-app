(ns audio-platform.services.media
  (:require
   ["package:file_picker/file_picker.dart" :as file-picker]
   ["package:http/http.dart" :as http]
   ["dart:io" :as io]
   ["dart:async" :as async]
   [clojure.string :as str]
   [audio-platform.services.api :as api]
   [audio-platform.state :as state]))

;; Global lock for media service
(defonce ^:private service-lock (atom false))

(defn upload-file [file-path presigned-url content-type on-progress]
  (let [file (io/File file-path)
        total-bytes (.lengthSync file)
        request (http/StreamedRequest. "PUT" (dart:core/Uri.parse presigned-url))
        client (http/Client.)]
    (set! (.-contentLength request) total-bytes)
    (.addAll (.-headers request) {"Content-Type" content-type})
    
    (let [bytes-sent (atom 0)
          stream (.openRead file)
          completer (async/Completer.)]
      (.listen stream
               (fn [chunk]
                 (swap! bytes-sent + (count chunk))
                 (when on-progress
                   (on-progress (/ (double @bytes-sent) total-bytes)))
                 (.add (.-sink request) chunk)
                 nil)
               .onDone (fn []
                         (.close (.-sink request))
                         (-> (.send client request)
                             (.then (fn [streamed-response]
                                      (-> (http/Response.fromStream streamed-response)
                                          (.then (fn [response]
                                                   (.close client)
                                                   (.complete completer response))))))
                             (.catchError (fn [err]
                                            (.close client)
                                            (.completeError completer err))))
                         nil)
               .onError (fn [err]
                          (.close (.-sink request))
                          (.close client)
                          (.completeError completer err)
                          nil))
      (.-future completer))))

(defn get-content-type [file-name]
  (let [ext (-> file-name (str/split #"\.") last str/lower-case)]
    (cond
      (or (= ext "jpg") (= ext "jpeg")) "image/jpeg"
      (= ext "png") "image/png"
      (= ext "gif") "image/gif"
      (= ext "mp3") "audio/mpeg"
      (= ext "wav") "audio/wav"
      :else "application/octet-stream")))

(defn- handle-upload-result [session-data file-path file-name file-size detected-content-type on-progress]
  (let [media-id (get session-data "media_id")
        presigned-url (get session-data "presigned_url")]
    (-> (upload-file file-path presigned-url detected-content-type on-progress)
        (.then 
         (fn [response]
           (let [status-code (.-statusCode response)]
             (if (not (and (>= status-code 200) (< status-code 300)))
               (throw (dart:core/Exception (str "Upload failed: HTTP " status-code)))
               (-> (api/mark-upload-complete (state/get-token) media-id :file-size file-size)
                   (.then (fn [_]
                            {:media-id media-id
                             :url (str api/base-url "/media/" media-id)
                             :file-info {:path file-path
                                        :name file-name
                                        :size file-size}}))))))))))

(defn- handle-picker-result [result on-progress content-type]
  (if (or (nil? result) (nil? (.-files result)) (empty? (.-files result)))
    (throw (dart:core/Exception "No file selected"))
    (let [file (first (.-files result))
          file-path (.-path file)
          file-name (.-name file)
          file-size (.-size file)
          detected-content-type (or content-type (get-content-type file-name))]
      (-> (api/create-upload-session (state/get-token) file-name :file-size file-size)
          (.then (fn [session-data]
                   (handle-upload-result session-data file-path file-name file-size detected-content-type on-progress)))))))

(defn pick-and-upload-file [& {:keys [type allowed-extensions on-progress content-type]}]
  (if @service-lock
    (do
      (dart:core/print "Ignoring pick-and-upload-file: service-lock is active")
      (async/Future.error (dart:core/Exception "Another file picker is already active")))
    (do
      (reset! service-lock true)
      (dart:core/print (str "pick-and-upload-file called with type: " type))
      (let [resolved-type (case type
                            :audio file-picker/FileType.any
                            :image file-picker/FileType.image
                            :video file-picker/FileType.video
                            :media file-picker/FileType.media
                            :any file-picker/FileType.any
                            :custom file-picker/FileType.custom
                            file-picker/FileType.any)]
        (-> (async/Future.delayed (dart:core/Duration .milliseconds 100))
            (.then (fn [_]
                     (dart:core/print "Native pickFiles call initiated after delay...")
                     (.pickFiles file-picker/FilePicker.platform
                                 .type resolved-type
                                 .allowedExtensions (when (= resolved-type file-picker/FileType.custom) allowed-extensions)
                                 .allowMultiple false)))
            (.timeout (dart:core/Duration .seconds 30)
                      .onTimeout (fn [] 
                                   (reset! service-lock false)
                                   (throw (async/TimeoutException. "File picker timed out after 30 seconds"))))
            (.then (fn [result] 
                     (reset! service-lock false)
                     (dart:core/print (str "Picker result received: " result))
                     (handle-picker-result result on-progress content-type)))
            (.catchError (fn [err]
                           (reset! service-lock false)
                           (dart:core/print (str "Picker error: " err))
                           (throw err))))))))
